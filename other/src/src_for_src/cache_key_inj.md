CACHE KEY INJECTION часть 1

- Как работает кэш?
Краткое объяснение:  Когда запрос получен, приложение решает, нужно ли его кэшировать. Если не вдаваться в подробности, то в этом
механизме кэшируются только неаутентифицированные GET-запросы.
Для каждого кэшируемого запроса создается уникальный "отпечаток пальца" запроса. Он называется ключом кэша. Цель ключа кэша - определить, какие запросы являются эквивалентными. Обычно он содержит URL, имя хоста и несколько заголовков запроса. Ключ не может содержать слишком много параметров, поскольку при слишком строгом значении кэш никогда и никому не будет передан. Например, если ключ кэша содержит заголовок referer, который не влияет на содержимое ответа. С другой стороны, если он слишком прост, кэш может обслуживаться некорректно, например, если в ключе кэша нет заголовка Accept, сервер может вернуть XML-ответ на запрос, который ожидает JSON.
Вот пример ключа кэша:

UNAUTH_CACHE_{ACCEPT HEADER}_{PROTOCOL}_{HOST}{HURI}

Затем он вставляется в базу данных Redis. Это простая ключевая база данных, и для нас важны только две очень простые операции:

SET(KEY, VALUE) - который устанавливает значение в базе данных
GET(KEY) - которая возвращает значение из базыданных.

Обе операции принимают ключ в виде необработанной строки - никаких подстановочных знаков, никаких расширенных запросов и никаких шансов для атаки типа SQLi.
Например для вот этого запроса:

GET / HTTP/1.1
Accept: text/html;q=0.9
Host: localhost
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; ×64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.199 Safari/ 537.36
Connection: close

будет создан вот такой ключ кэша: 
UNAUTH_CACHE_text/html;q=0.9_http_localhost/
и вот так будет выполняться в redis: 
SET("UNAUTH_CACHE_text/html;q=0.9_http_localhost/", "<html>*RESPONSE CONTENT*</html>")

Затем так же выполняется второй SET для заголовков и так далее. После того как приходит новый запрос,он решает можно ли его кэшировать и если да, то создает ключ кэша

GET("UNAUTH_CACHE_text/html;q=0.9_http_localhost/")

Если значение присутствует в базе данных, то пользователю выдается ответ.

Инъекция ключа кэша - это класс ошибок, которые крайне сложно обнаружить с помощью подхода "черного ящика". Не имея доступа к исходному коду или хотя бы возможности увидеть ключ кэша, я бы сказал, что обнаружить его практически невозможно. Нужно знать, какие вещи включены в ключ кэша, каков их разделитель и каков порядок.

- Инъекция ключа кэша
На данном этапе наша единственная цель - создать два запроса к разным конечным точкам, которые будут иметь один и тот же ключ кэша. Причем только один из них мы можем модифицировать в Burp, а второй должен быть отправлен из браузера жертвы. Это означает, что мы не можем вмешиваться в такие заголовки, как Host, Origin, User-Agent и т.д..
Первое, что необходимо проверить, - это то, является ли разделитель различных атрибутов в кэш-ключе экранированным. Если это так, то это означает, что инъекция ключа кэша отсутствует.

GET / HTTP/1.1
Accept: text/html; q=0.9_
Host: localhost
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; ×64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.199 Safari/537.36
Connection: close

В этом приложении разделителем является _. Когда я отправляю этот запрос с разделителем в заголовке accept, я вижу, что он был вставлен в redis без всякого экранирования. 
UNAUTH_CACHE_text/html;q=0.9__http_localhost/ (наверное вам не видно, но между 9 и h два нижних подчеркивания)
Это означает, что инъекция ключа кэша присутствует. Теперь попробуем обмануть сервер, что это кэш для другого запроса, а не для кого он есть на самом деле. 

- Какой вход использовать для инъекции?
*URI запроса - это может работать, но мы хотим переопределить именно этот параметр, поэтому лучше выбрать что-то другое
*HOST - на самом деле, я даже не контролирую этот параметр - он берется не из заголовка Host, а из конфигурации 
*PROTOCOL - вмешательство в него приведет к поломке запроса
*Заголовок ACCEPT - здесь все идеально - он находится перед путем, и я могу добавить произвольный ввод без отказа в запросе.

Ethical hacking instruction notes [2], [10/2/23 10:23 AM]
CACHE KEY INJECTION часть 2

- Что вводить?

GET /arbitrary-path HTTP/1.1
Accept: text/html;q=0.9_http_localhost/victims/path?a
Host: localhost
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; ×64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.199 Safari/537.36
Connection: close
Рассмотрим запрос выше

_CACHE_text/html;9=0.9_http_localhost/victims/path?a_http_localhost/arbitrary/path

инъекцию можно разделить на несколько частей
*обычный заголовок Accept, который будет отправлен браузером жертвы (text/html;9=0.9)
*обычная часть ключа кэша, которую я не хочу изменять - PROTO и HOST часть (_http_localhost)
*ключа кэша, которую хочу внедрить - URI
*остальное, что позволит воссоздать ключ по запросу жертвы. Во многих инъекционных атаках мы завершаем нежелательный добавленный ввод комментарием или нулевым байтом. Однако в случае Redis это невозможно
Отброшенная часть находится там потому, что для перехода от заголовка Accept к пути мы должны были внедрить
протокол и хост по пути. Но, очевидно, приложение этого не знает и после нашего вредоносного заголовка Accept инжектирует реальный протокол, хост и URI.

Вот два запроса. Верхний запрос отправлен нами, а второй - легитимный запрос, отправленный из браузера жертвы.
Запрос:
GET /arbitrary-path HTTP/1.1
Accept: text/html;q=0.9_http_localhost/victims/path?a
Host: localhost
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; ×64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.199 Safari/ 537.36
Connection: close

Ключ:
_CACHE_text/html;q=0.9_http_localhost/victims/path?a(ACCEPT)_http_localhost(PROTO and HOST)/arbitrary/path(URI)

Запрос:
GET /victims/path?a_http_localhost/arbitrary-path HTTP/1.1
Accept: text/html;q=0.9
Host: localhost
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; ×64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.199 Safari/ 537.36
Connection: close

Ключ:
_CACHE_text/html;q=0.9(ACCEPT)_http_localhost(PROTO and HOST)/victims/path?a_http_localhost/arbitrary/path(URI)

Как видите, ключи кэша одинаковы. Но, к сожалению, чтобы добиться этого, нам придется внести некоторые элементы в URI жертвы. Это далеко не идеальный вариант. Это снижает риск нашей атаки с возможности "отравить" любого пользователя до требования посетить URL, посланный нами. Однако для многих атак мы требуем, чтобы
жертва посетила наш URL, так что это не конец света.
Убедиться в том, что кэш-инъекция сработала, можно, отправив два запроса - первый из Burp, второй - из браузера.
Если мы все выполнили правильно, то на второй запрос к /victims/path должен быть получен ответ /arbitrary-path. Это доказывает, что у нас есть инъекция ключа кэша.

- В чем импакт?

Какие последствия это может иметь? Вот что меня раздражает в этом типе ошибок. Вам нужно что-то еще, чтобы добиться реального воздействия. Этим "чем-то" может быть обычно невозможная к эксплуатации атака, например, XSS через заголовки Host или Origin. Это те вещи, которые вы обычно не можете эксплуатировать, потому что не можете контролировать их в браузере жертвы. Но с помощью этой атаки вы могли бы отправить его, например, в заголовке Origin. Если он отражается в ответе, вызывая XSS, ответ будет закэширован. Но поскольку заголовок Origin не является частью ключа кэша, легитимной жертве также может быть предоставлен наш XSS.

Так что если вы когда-нибудь столкнетесь с невозможным к эксплуатации XSS через такие вещи, как заголовок Host, заголовок Origin или, возможно, куки, не сообщайте об этом. Вероятно, вы получите ничего или низкую выплату, тем самым лишив хорошую выплату того, кто позже обнаружит инъекцию ключа кэша или другую подобную атаку.